<!DOCTYPE html>
<html>
    <head>
        <title>Shaderium</title>
        <meta charset="utf-8"/>
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
        <link rel="stylesheet" href="Scripts/codemirror-5.47.0/lib/codemirror.css"/>
        <link rel="stylesheet" href="style.css"/>

        <meta name="title" content="Shaderium"/>
        <meta name="description"
                content="Look at various shaders in real time and write you own ones."/>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
        <meta name="keywords" content="indie, math, real time, webgl, shader"/>
        <meta name="url" content="https://cook1eegames.feedia.co/Shaderium"/>
        <meta name="og:title" content="Shaderium"/>
        <meta name="og:type" content="website"/>
        <meta name="og:url" content="https://cook1eegames.feedia.co/Shaderium"/>
        <meta name="og:description"
                content="Look at various shaders in real time and write you own ones."/>
        <meta name="og:image" content="https://cook1eegames.feedia.co/Images/Previews/shaderium.png"/>
        <meta name="twitter:card" content="summary_large_image"/>
        <meta name="twitter:title" content="Shaderium"/>
        <meta name="twitter:description"
                content="Look at various shaders in real time and write you own ones."/>
        <meta name="twitter:image" content="https://cook1eegames.feedia.co/Images/Previews/shaderium.png"/>
        <meta name="twitter:site" content="@cook1eegames"/>
        <meta name="twitter:creator" content="@cook1eegames"/>
    </head>

    <body>
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <label>Enable Slow Update <input id="opt_slowupdate" type="checkbox"/></label>&emsp;
                    <button id="btn_createshader">Write you own Shader (experimental)</button>
                    <button id="btn_exportshaders">Export Shaders</button>
                    <button id="btn_importshaders">Import Shaders</button>
                </div>
            </div>
        </nav>


        <div class="container-fluid">
            <div id="canvascontainer" class="row">
            </div>
        </div>
        

        <div class="overlay"></div>

        <p class="fullscreeninfo">Welcome to Shaderium<br/>Click on a Shader Image to make it bigger</p>

        <div class="ide">
            <h1>Shader Creator</h1>
            <p>Welcome to the Shader editor! You can write your own Shaders here in GLSL.</p>
            <p>Uniforms:</p>
            <ul>
                <li><span class="codepurple">float</span> iTime: seconds (a value between 0 and 100.000, based on date)</li>
                <li><span class="codepurple">vec2</span> iResolution</li>
            </ul>
            <br/>
            <label>Author <input id="ide_input_author" placeholder="Your Name"/></label><br/>
            <label>Shader Name <input id="ide_input_name" placeholder="Shader Name"/></label><br/>
            <span id="ide_compile_info"></span><br/>
            <button id="btn_compile">Compile</button>&emsp;
            <button id="btn_exit">Exit</button>
            <textarea id="textarea_code">
#version 100

precision mediump float;

uniform float iTime;
uniform vec2 iResolution;

void main()
{
    //Your code here
    //gl_FragColor is the output pixel color (r, g, b, a)
    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
}</textarea><br/>
        </div>

        <script id="vertexshader" type="x-shader/x-vertex">
            #version 100
            
            attribute vec2 coordinates;
            
            void main()
            {
                gl_Position = vec4(coordinates, 0.0, 1.0);
            }
        </script>
    
        <script class="fragshader" data-name="Binary wobble clock" data-author="default" type="x-shader/x-fragment">#version 100

precision mediump float;

uniform float iTime;
uniform vec2 iResolution;

void main()
{
    vec2 uv = gl_FragCoord.xy / iResolution;
    vec2 coord = 2.0 * 20.0 * (uv - vec2(.5, .5));
    
    coord.x *= iResolution.x / iResolution.y;
    coord.x *= 1.0 + 0.075 * cos(iTime * 4.5);
    coord.y *= 1.0 + 0.075 * sin(iTime * 4.5);
    coord += 0.25 * vec2(sin(coord.x * 1.5), 
                        cos(coord.y * 1.5));
    float angle = atan(coord.y, coord.x);
    float dist = sqrt(coord.x * coord.x + coord.y * coord.y);
    
    vec3 col;
    
    float timeScale = 1.0;

    float base = 2.0 * pow(2.0, floor(dist)) / timeScale;
    if(mod(iTime, base) > base / 2.0)
    {
        col = vec3(sin(dist), sin(dist + 2.5), sin(dist + 3.5));
    }
    
    gl_FragColor = vec4(col, 1.0);
}</script>

        <script class="fragshader" data-name="Circular Black Hole" data-author="default" type="x-shader/x-fragment">#version 100

precision mediump float;

uniform float iTime;
uniform vec2 iResolution;

void main()
{
    float pi = 3.1415926;

    vec2 uv = gl_FragCoord.xy / iResolution.xy;

    vec2 coord = 20.0 * 2.0 * (uv - vec2(.5, .5));
    coord.x *= iResolution.x / iResolution.y;
    coord *= 1.0 - mod(iTime * 0.5, 0.25) * 1.0 + 0.4 * sin(iTime / 1.3);

    float angle = atan(coord.x, coord.y);
    angle += iTime * 2.2;
    float objAngle = angle + iTime * -0.7;
    float dist = sqrt(coord.x * coord.x + coord.y * coord.y);

    vec3 col;

    if(mod(angle, 2.0 * pi / 3.0) > pi / 3.0)
    {
        col = vec3(1, 1, 1) * 1.0 - mod(iTime, 0.5);
    }
    else
    {
        col = vec3(0, 0, 0);
    }

    if(dist <= 1.5)
    {
        col = vec3(1, 1, 1);
    }

    if(mod(objAngle + 14.0 * floor(dist * 0.1), 2.0 * pi / 5.0) < pi / 10.0 && mod(dist + iTime * 7.0, 4.5) < 1.0)
    {
        col += vec3(.75, .75, .95);
    }

    gl_FragColor = vec4(col,1.0);
}</script>

        <script class="fragshader" data-name="Center of the Galaxy" data-author="default" type="x-shader/x-fragment">#version 100

precision mediump float;

uniform float iTime;
uniform vec2 iResolution;

float dist(vec2 v)
{
    return sqrt(v.x * v.x + v.y * v.y);
}

float dist2(vec2 f, vec2 t)
{
    vec2 d = t - f;
    return sqrt(d.x * d.x + d.y * d.y);
}

void main()
{
    vec2 uv = gl_FragCoord.xy/iResolution.xy;
    float movesize = 50.0;
    float aspect = iResolution.x / iResolution.y;
    vec2 coord = movesize * 1.25 * 2.0 * (uv - vec2(.5, .5));
    coord.x *= aspect;
    vec2 origCoord = coord; //for black hole
    
    if(dist(coord) < 17.0)
    {
        coord *= pow(dist(coord) / 17.0, 3.0);
        coord += 0.15 * (cos(coord.x + iTime * 100.0) + 
                        sin(coord.y + iTime * 100.0));
    }
    
    float val = 0.0;
    float timescale = 0.025;
    
    for(int i = 0; i < 30; i++)
    {
        float j = float(i);
        vec2 intvl = timescale * vec2(5.0 + 5.0 * sin(j), 7.0 + 7.0 * sin(j * 1.5));
        float size = 1.0 + 0.6 * sin(j);
        float v = size - dist2(vec2(movesize * aspect * cos(iTime * intvl.x), 
                                movesize * sin(iTime * intvl.y)), coord);
        val += max(0.0, v);
    }
    
    
    vec3 col = val * vec3(1.5, 1.25, 1);
    
    float nebula;
    for(int i = 0; i < 3; i++)
    {
        float intvl = 0.02 + 0.01 * float(i);
        float offsetx = float(i) * 4.0 + iTime * float(i);
        float offsety = float(i) * 3.0 + iTime - float(i);
        nebula += 0.2 * (cos(coord.x * intvl + offsetx) + 
                            sin(coord.y * intvl + offsety));
    }
    col += nebula * vec3(1.5, 1.2, 0.8);
    
    if(dist(origCoord) < 7.5) col = vec3(0, 0, 0);
    
    // Output to screen
    gl_FragColor = vec4(col,1.0);
}</script>

        <script class="fragshader" data-name="Rotational Madness" data-author="default" type="x-shader/x-fragment">#version 100

precision mediump float;

uniform float iTime;
uniform vec2 iResolution;

void main()
{
    float pi = 3.1415926;
    vec2 uv = gl_FragCoord.xy/iResolution.xy;
    vec2 coord = 20.0 * 2.0 * (uv - vec2(.5, .5));
    coord.x *= iResolution.x / iResolution.y;
    
    float dist = sqrt(coord.x * coord.x + coord.y * coord.y);
    float angle = atan(coord.y, coord.x) + iTime * 0.5;
    angle += 0.2 * tan(iTime * 0.4);
    
    if(mod(angle, 2.0 * pi / 4.0) > pi / 4.0)
    {
        dist += 5.0 + 5.0 * sin(iTime * 2.0);
    }
    
    vec3 col;

    col = (sin(dist * 7.0) + sin(angle * 15.0)) * vec3(1, 1, 1);
    
    col.xy *= clamp(0.5 + 0.25 * (cos(coord.x) + sin(coord.y)), 0.5, 1.0);
    
    float rotationangle = angle - 3.0 * iTime;
    if(mod(rotationangle, 2.0 * pi) < 1.0)
    {
        col += 0.5 * vec3(1, 1, 1);
    }
    
    gl_FragColor = vec4(col,1.0);
}</script>

        <script class="fragshader" data-name="Flapping Mandelbrot" data-author="default" type="x-shader/x-fragment">#version 100

precision mediump float;

uniform float iTime;
uniform vec2 iResolution;

vec2 squareVec(vec2 v)
{
    return vec2(v.x * v.x - v.y * v.y, 2.0 * v.x * v.y);
}

void main()
{
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = gl_FragCoord.xy/iResolution.xy;
    vec2 c = 2.0 * 2.0 * (uv - vec2(.5, .5)) + vec2(-0.25, 0.0);
    c.x *= iResolution.x / iResolution.y;
    c += 0.01 * vec2(cos(iTime * 3.5 + c.x * 15.0), 
                    sin(iTime * 3.5 + c.y * 15.0));
    c.x += abs(c.y * (0.5 + 0.5 * sin(iTime * 2.0)));
    
    int itr = 0;
    vec2 z = vec2(c.x, c.y);
    
    for(int i = 0; i < 32; i++)
    {
        c = squareVec(c) + z;
        
        if(sqrt(c.x * c.x + c.y * c.y) > 16.0) break;
        itr++;
    }
    
    // Time varying pixel color
    vec3 col;
    float j = float(itr) / 3.0;
    col = vec3(sin(j), cos(j), sin(j));
    
    if(itr == 32)
    {
        col = vec3(0, 0, 0);
    }
    
    // Output to screen
    gl_FragColor = vec4(col, 1.0);
} </script>

        <script class="fragshader" data-name="Infinite Zoom" data-author="default" type="x-shader/x-fragment">#version 100

precision mediump float;

uniform float iTime;
uniform vec2 iResolution;

float log10(float n)
{
    return log(n) / log(10.0);
}

void main()
{
    float pi = 3.1415926;
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = gl_FragCoord.xy / iResolution.xy;
    vec2 coord = 20.0 * 2.0 * (uv - vec2(.5, .5));
    coord.x *= iResolution.x / iResolution.y;

    float magn = -iTime * 1.5;
    
    float dist = log10(sqrt(coord.x * coord.x + coord.y * coord.y)) + magn;
    float angle = atan(coord.y, coord.x);
    
    vec3 col;
    
    float sides = 2.0 * pow(2.0, mod(floor(-dist / 10.0), 7.0));
    if(mod(dist, 100.0) > 60.0 && mod(angle, 2.0 * pi / sides) > pi / sides)
    {
        float r = sin(dist);
        float g = sin(dist + pi * 1.75 / 3.0);
        float b = sin(dist + pi * 3.5 / 3.0);
        col = vec3(r, g, b);
    }
    else if(mod(dist, 100.0) > 30.0 && mod(dist, 100.0) < 60.0 && mod(angle + dist, 2.0 * pi / sides * 2.0) > pi / sides * 1.5)
    {
        float r = mod(dist, 5.0) > 2.5 ? 1.0 : 0.0;
        col = vec3(r, 0.5, 0.5);
    }
    else if(mod(dist, 100.0) > 0.0 && mod(dist, 100.0) < 30.0 && mod(angle + 2.5 * dist, 2.0 * pi / sides * 4.0) > pi / sides * 5.0)
    {
        if(mod(dist, 1.0) > 0.6)
        {
            col = vec3(1, 1, 1);
        }
        else
        {
            col = mod(dist / 200.0, 0.3) * vec3(1, 1, 1);
        }
    }
    else
    {
        col = mod(dist / 200.0, 0.3) * vec3(1, 1, 1);
    }

    gl_FragColor = vec4(col, 1.0);
} </script>

        <script src="Scripts/codemirror-5.47.0/lib/codemirror.js"></script>
        <script src="Scripts/codemirrorsimple.js"></script>
        <script src="Scripts/glslmode.js"></script>
        <script src="Scripts/main.js"></script>
    </body>
    
</html>